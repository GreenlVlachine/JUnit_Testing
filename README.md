# How can I ensure that my code, program, or software is functional and secure?

Practicing and employing good coding practices such as minimizing the use of duplicate code, appropriate name schemes, and so on, set a good foundation for the functionality of code.  Frequent and early testing such as the techniques practiced throughout this course will allow developers to find and correct bugs efficiently.  For code security, there is still much I would like to learn how to implement.  Tools such as authentication and encryption will help to protect from possible attacks.  Runtime logs, incident reports, proper documentation, and software updates - these are all important aspects in the development of functional and secure coding.

# How do I interpret user needs and incorporate them into a program?

There are several ways to interpret user needs, which we've done more in-depth research in other courses in the program.  Requirement gathering in the form of interviews, questionnaires, or surveys will allow you to take the user's needs and goals and create user stories.  These stories serve as building blocks for developers to begin implementing desired features.  Working in sprints and collaborating with the stakeholders to show progress, maintain alignment, and receive feedback are all commonly practiced parts of the agile methodology we have been taught, allowing for flexibility and efficiency.

# How do I approach designing software?

When designing software, the first thing I do is look towards the rubric for the assignment (my 'user needs') to better understand the scope of the problem I'm intended to solve.  I then created all the classes I knew I would be using, got my constructors and setters/getters, and started writing tests as soon as I could.  As I am still in the early stages of my developer education, I find myself looking for a lot of examples still.  It is important to me to seek improvement with each assignment.  If I can continue learning new applications and adding more tools to my belt, I will continue to develop better and more efficient software.
